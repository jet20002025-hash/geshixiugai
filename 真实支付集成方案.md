# 真实支付集成方案

## 概述

当前系统使用模拟支付（mock payment）。要实现真实支付，需要集成以下支付平台：

- **支付宝支付**（Alipay）- 国内用户主要使用
- **微信支付**（WeChat Pay）- 国内用户主要使用
- **Stripe**（可选）- 国际用户使用

## 一、支付宝支付集成

### 1.1 申请支付宝开放平台账号

1. 访问：https://open.alipay.com/
2. 注册/登录支付宝开放平台账号
3. 完成企业认证（需要营业执照）
4. 创建应用，获取：
   - `APPID`（应用ID）
   - `APP_PRIVATE_KEY`（应用私钥）
   - `ALIPAY_PUBLIC_KEY`（支付宝公钥）

### 1.2 安装支付宝 SDK

```bash
pip install python-alipay-sdk
```

添加到 `requirements.txt`：
```
python-alipay-sdk==3.7.0
```

### 1.3 配置环境变量

在 Vercel Dashboard → Environment Variables 中添加：

```
ALIPAY_APP_ID=你的应用ID
ALIPAY_PRIVATE_KEY=你的应用私钥（需要去掉换行符）
ALIPAY_PUBLIC_KEY=支付宝公钥（需要去掉换行符）
ALIPAY_SIGN_TYPE=RSA2
ALIPAY_GATEWAY=https://openapi.alipay.com/gateway.do  # 正式环境
# ALIPAY_GATEWAY=https://openapi.alipaydev.com/gateway.do  # 沙箱环境（测试用）
```

### 1.4 代码实现

创建 `backend/app/services/alipay_service.py`：

```python
import os
from alipay import AliPay
from alipay.utils import AliPayConfig

class AlipayService:
    def __init__(self):
        self.app_id = os.getenv("ALIPAY_APP_ID")
        self.app_private_key = os.getenv("ALIPAY_PRIVATE_KEY")
        self.alipay_public_key = os.getenv("ALIPAY_PUBLIC_KEY")
        self.sign_type = os.getenv("ALIPAY_SIGN_TYPE", "RSA2")
        self.gateway = os.getenv("ALIPAY_GATEWAY", "https://openapi.alipay.com/gateway.do")
        
        self.alipay = AliPay(
            appid=self.app_id,
            app_notify_url=None,  # 支付回调地址
            app_private_key_string=self.app_private_key,
            alipay_public_key_string=self.alipay_public_key,
            sign_type=self.sign_type,
            debug=False,  # 生产环境设为 False
            config=AliPayConfig(timeout=15)
        )
    
    def create_payment(self, order_id: str, amount: float, subject: str) -> dict:
        """
        创建支付订单
        
        Args:
            order_id: 订单ID（使用 document_id）
            amount: 支付金额
            subject: 订单标题
            
        Returns:
            支付参数，前端用于调起支付宝支付
        """
        order_string = self.alipay.api_alipay_trade_page_pay(
            out_trade_no=order_id,
            total_amount=str(amount),
            subject=subject,
            return_url="https://geshixiugai.org/web/payment/success",  # 支付成功跳转地址
            notify_url="https://geshixiugai.org/api/payments/alipay/notify",  # 支付回调地址
        )
        
        # 生成支付URL
        payment_url = f"{self.gateway}?{order_string}"
        
        return {
            "payment_url": payment_url,
            "order_string": order_string,
        }
    
    def verify_notify(self, data: dict) -> bool:
        """
        验证支付回调通知
        
        Args:
            data: 支付宝回调数据
            
        Returns:
            True 如果验证通过
        """
        return self.alipay.verify(data, data.get("sign"))
```

### 1.5 添加支付 API

在 `backend/app/api/payments.py` 中添加：

```python
@router.post(
    "/alipay/create",
    summary="创建支付宝支付订单",
)
async def create_alipay_payment(payload: PaymentRequest) -> dict:
    """创建支付宝支付订单，返回支付URL"""
    from ..services.alipay_service import AlipayService
    
    service = PaymentService(document_dir=DOCUMENT_DIR, template_dir=TEMPLATE_DIR)
    amount = service.calculate_price(payload.document_id)
    
    alipay_service = AlipayService()
    payment_data = alipay_service.create_payment(
        order_id=payload.document_id,
        amount=amount,
        subject=f"论文格式修复服务 - {payload.document_id[:8]}"
    )
    
    return {
        "payment_url": payment_data["payment_url"],
        "document_id": payload.document_id,
    }

@router.post(
    "/alipay/notify",
    summary="支付宝支付回调",
)
async def alipay_notify(request: Request) -> dict:
    """处理支付宝支付回调通知"""
    from ..services.alipay_service import AlipayService
    
    data = await request.form()
    data_dict = dict(data)
    
    alipay_service = AlipayService()
    if alipay_service.verify_notify(data_dict):
        # 验证通过，标记订单为已支付
        document_id = data_dict.get("out_trade_no")
        payment_service = PaymentService(document_dir=DOCUMENT_DIR, template_dir=TEMPLATE_DIR)
        payment_service.mark_as_paid(document_id, payment_method="alipay")
        
        return {"status": "success"}
    else:
        return {"status": "fail", "message": "签名验证失败"}
```

## 二、微信支付集成

### 2.1 申请微信支付商户号

1. 访问：https://pay.weixin.qq.com/
2. 注册微信支付商户号（需要企业资质）
3. 完成认证后获取：
   - `APPID`（应用ID）
   - `MCHID`（商户号）
   - `API_KEY`（API密钥）
   - `CERT_PATH`（证书路径，可选）

### 2.2 安装微信支付 SDK

```bash
pip install wechatpay-python
```

添加到 `requirements.txt`：
```
wechatpay-python==1.1.0
```

### 2.3 配置环境变量

```
WECHAT_APP_ID=你的应用ID
WECHAT_MCH_ID=你的商户号
WECHAT_API_KEY=你的API密钥
WECHAT_NOTIFY_URL=https://geshixiugai.org/api/payments/wechat/notify
```

### 2.4 代码实现

创建 `backend/app/services/wechat_service.py`：

```python
import os
from wechatpayv3 import WeChatPay, WeChatPayType

class WeChatPayService:
    def __init__(self):
        self.app_id = os.getenv("WECHAT_APP_ID")
        self.mch_id = os.getenv("WECHAT_MCH_ID")
        self.api_key = os.getenv("WECHAT_API_KEY")
        self.notify_url = os.getenv("WECHAT_NOTIFY_URL")
        
        self.wechatpay = WeChatPay(
            wechatpay_type=WeChatPayType.NATIVE,  # 扫码支付
            mchid=self.mch_id,
            private_key_path=None,  # 如果使用证书
            cert_serial_no=None,
            appid=self.app_id,
            notify_url=self.notify_url,
            key=self.api_key,
        )
    
    def create_payment(self, order_id: str, amount: float, description: str) -> dict:
        """
        创建微信支付订单
        
        Args:
            order_id: 订单ID
            amount: 支付金额（单位：分）
            description: 订单描述
            
        Returns:
            支付参数
        """
        # 金额转换为分
        amount_cents = int(amount * 100)
        
        code, message = self.wechatpay.pay(
            description=description,
            out_trade_no=order_id,
            amount={"total": amount_cents, "currency": "CNY"},
        )
        
        if code == 200:
            return {
                "code_url": message.get("code_url"),  # 支付二维码URL
                "prepay_id": message.get("prepay_id"),
            }
        else:
            raise Exception(f"微信支付创建失败: {message}")
    
    def verify_notify(self, headers: dict, body: str) -> dict:
        """
        验证微信支付回调
        
        Args:
            headers: 请求头
            body: 请求体
            
        Returns:
            解析后的订单数据
        """
        result = self.wechatpay.callback(headers, body)
        return result
```

### 2.5 添加支付 API

在 `backend/app/api/payments.py` 中添加：

```python
@router.post(
    "/wechat/create",
    summary="创建微信支付订单",
)
async def create_wechat_payment(payload: PaymentRequest) -> dict:
    """创建微信支付订单，返回支付二维码"""
    from ..services.wechat_service import WeChatPayService
    
    service = PaymentService(document_dir=DOCUMENT_DIR, template_dir=TEMPLATE_DIR)
    amount = service.calculate_price(payload.document_id)
    
    wechat_service = WeChatPayService()
    payment_data = wechat_service.create_payment(
        order_id=payload.document_id,
        amount=amount,
        description=f"论文格式修复服务"
    )
    
    return {
        "code_url": payment_data["code_url"],
        "document_id": payload.document_id,
    }

@router.post(
    "/wechat/notify",
    summary="微信支付回调",
)
async def wechat_notify(request: Request) -> dict:
    """处理微信支付回调通知"""
    from ..services.wechat_service import WeChatPayService
    
    headers = dict(request.headers)
    body = await request.body()
    
    wechat_service = WeChatPayService()
    result = wechat_service.verify_notify(headers, body.decode())
    
    if result and result.get("trade_state") == "SUCCESS":
        document_id = result.get("out_trade_no")
        payment_service = PaymentService(document_dir=DOCUMENT_DIR, template_dir=TEMPLATE_DIR)
        payment_service.mark_as_paid(document_id, payment_method="wechat")
        
        return {"code": "SUCCESS", "message": "成功"}
    else:
        return {"code": "FAIL", "message": "处理失败"}
```

## 三、前端集成

### 3.1 修改前端支付逻辑

在 `frontend/index.html` 中修改 `handlePayment` 函数：

```javascript
async function handlePayment(documentId, paymentMethod) {
  if (!paymentMethod) {
    showMessage(resultStatus, "请选择支付方式", true);
    return;
  }

  try {
    showMessage(resultStatus, "处理支付中...", false);
    
    if (paymentMethod === "mock") {
      // 模拟支付（测试用）
      const response = await fetch("/payments/mock", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ 
          document_id: documentId,
          payment_method: paymentMethod
        }),
      });
      
      if (!response.ok) {
        const detail = await response.json();
        throw new Error(detail.detail || "支付失败");
      }
      
      const paymentResult = await response.json();
      
      // 保存下载 token
      if (paymentResult.download_token) {
        localStorage.setItem(`download_token_${documentId}`, paymentResult.download_token);
      }
      
      showMessage(resultStatus, "支付成功，正式版已解锁！", false);
      await refreshDocumentStatus();
      
    } else if (paymentMethod === "alipay") {
      // 支付宝支付
      const response = await fetch("/payments/alipay/create", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ 
          document_id: documentId,
          payment_method: "alipay"
        }),
      });
      
      if (!response.ok) {
        throw new Error("创建支付订单失败");
      }
      
      const paymentData = await response.json();
      
      // 跳转到支付宝支付页面
      window.location.href = paymentData.payment_url;
      
    } else if (paymentMethod === "wechat") {
      // 微信支付
      const response = await fetch("/payments/wechat/create", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ 
          document_id: documentId,
          payment_method: "wechat"
        }),
      });
      
      if (!response.ok) {
        throw new Error("创建支付订单失败");
      }
      
      const paymentData = await response.json();
      
      // 显示支付二维码
      showWeChatQRCode(paymentData.code_url, documentId);
      
    } else {
      showMessage(resultStatus, `${paymentMethod} 支付功能开发中...`, true);
    }
  } catch (error) {
    console.error("支付错误:", error);
    showMessage(resultStatus, error.message || "支付失败，请稍后重试", true);
  }
}

// 显示微信支付二维码
function showWeChatQRCode(codeUrl, documentId) {
  // 创建二维码显示模态框
  const modal = document.createElement("div");
  modal.style.cssText = "position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 3000; display: flex; align-items: center; justify-content: center;";
  
  modal.innerHTML = `
    <div style="background: white; padding: 30px; border-radius: 12px; text-align: center;">
      <h3>微信支付</h3>
      <p>请使用微信扫描二维码完成支付</p>
      <img src="https://api.qrserver.com/v1/create-qr-code/?size=300x300&data=${encodeURIComponent(codeUrl)}" alt="支付二维码" style="width: 300px; height: 300px; margin: 20px 0;">
      <button onclick="this.closest('div').parentElement.remove(); checkPaymentStatus('${documentId}')">已完成支付</button>
      <button onclick="this.closest('div').parentElement.remove();" style="margin-left: 10px;">取消</button>
    </div>
  `;
  
  document.body.appendChild(modal);
  
  // 轮询检查支付状态
  const checkInterval = setInterval(() => {
    checkPaymentStatus(documentId).then(paid => {
      if (paid) {
        clearInterval(checkInterval);
        modal.remove();
        refreshDocumentStatus();
      }
    });
  }, 3000); // 每3秒检查一次
}

// 检查支付状态
async function checkPaymentStatus(documentId) {
  try {
    const response = await fetch(`/documents/${documentId}/status`);
    const data = await response.json();
    return data.paid;
  } catch (error) {
    return false;
  }
}
```

## 四、支付流程

### 4.1 支付宝支付流程

1. 用户选择"支付宝"支付方式
2. 前端调用 `/payments/alipay/create` 创建订单
3. 后端返回支付URL
4. 前端跳转到支付宝支付页面
5. 用户完成支付
6. 支付宝回调 `/payments/alipay/notify`
7. 后端验证签名，标记订单为已支付
8. 用户跳转回成功页面，可以下载文档

### 4.2 微信支付流程

1. 用户选择"微信支付"
2. 前端调用 `/payments/wechat/create` 创建订单
3. 后端返回支付二维码URL
4. 前端显示二维码
5. 用户使用微信扫码支付
6. 微信回调 `/payments/wechat/notify`
7. 后端验证签名，标记订单为已支付
8. 前端轮询检查支付状态，支付成功后可以下载文档

## 五、注意事项

### 5.1 安全性

1. **私钥保护**：私钥必须存储在环境变量中，不要提交到代码仓库
2. **签名验证**：所有支付回调必须验证签名，防止伪造
3. **HTTPS**：生产环境必须使用 HTTPS
4. **订单验证**：验证订单金额、订单ID等关键信息

### 5.2 测试环境

1. **支付宝沙箱**：使用沙箱环境进行测试
   - 沙箱网关：`https://openapi.alipaydev.com/gateway.do`
   - 沙箱账号：https://open.alipay.com/develop/sandbox/app

2. **微信支付沙箱**：使用微信支付沙箱环境测试

### 5.3 费用

- **支付宝**：按交易金额收取手续费（通常 0.6%）
- **微信支付**：按交易金额收取手续费（通常 0.6%）
- **Stripe**：按交易金额收取手续费（通常 2.9% + $0.30）

### 5.4 回调地址配置

支付回调地址必须在支付平台配置：
- 支付宝：开放平台 → 应用 → 功能信息 → 支付回调地址
- 微信支付：商户平台 → 开发配置 → 支付回调地址

## 六、快速开始

### 6.1 使用第三方支付聚合平台（推荐）

如果不想直接对接支付宝/微信，可以使用第三方聚合支付平台：

1. **Ping++**：https://www.pingxx.com/
2. **BeeCloud**：https://beecloud.cn/
3. **PayJS**：https://payjs.cn/

这些平台提供统一的 API，支持多种支付方式，集成更简单。

### 6.2 推荐方案

对于 MVP 阶段，建议：
1. **先使用模拟支付**进行功能测试
2. **使用第三方聚合平台**（如 Ping++）快速接入真实支付
3. **后期再考虑**直接对接支付宝/微信（如果需要更低的手续费）

## 七、总结

实现真实支付需要：
1. ✅ 申请支付平台账号（支付宝/微信）
2. ✅ 安装支付 SDK
3. ✅ 配置环境变量
4. ✅ 实现支付创建和回调接口
5. ✅ 修改前端支付逻辑
6. ✅ 配置支付回调地址
7. ✅ 测试支付流程

建议先使用第三方聚合支付平台快速接入，后期再考虑直接对接。



